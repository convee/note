# PHP 面试要点

## 简单做一下自我介绍?  介绍一下三年内最得意的项目？

## **操作系统**

- IO 多路复用是什么？有哪些 api？

- select 和 epoll 的区别？水平触发和边缘触发的区别是啥？使用的时候需要注意什么？

- epoll 储存描述符的数据结构是什么？

- select 有描述符限制吗？是多少？

- 进程 / 线程 / 协程区别？go 和 swoole 的协程实现有啥区别？（分配资源的基本单位 / 运行和调度的基本单位 / 用户线程，M:N 模型和 N:1 模型）
## **计算机网络**

- TCP 三次握手和四次挥手，为什么三次握手，为什么四次挥手
    在Tcp连接中，服务端的SYN和ACK向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的ACK和FIN是分两次发送的。因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了
    
- 一次完整的 HTTP 请求（从浏览器输入 www.baidu.com 到加载出页面发生了什么）
    1. dns 解析 ip 
    2. 建立 tcp 连接 
    3. 发送 HTTP 报文 
    4. 接收 HTTP 报文 
    5. 浏览器解析显示

- HTTP 协议包括哪些请求？
    1. GET：请求读取由URL所标志的信息。
    2. POST：给服务器添加信息（如注释）。
    3. PUT：在给定的URL下存储一个文档。
    4. DELETE：删除给定的URL所标志的资源。

- GET 和 POST 区别
    1. GET在浏览器回退时是无害的，而POST会再次提交请求。
    2. GET产生的URL地址可以被Bookmark，而POST不可以。
    3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
    4. GET请求只能进行url编码，而POST支持多种编码方式application/x-www-form-urlencoded，multipart/form-data，application/json，text/xml
    5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
    6. GET请求在URL中传送的参数是有长度限制的，而POST没有。
    7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
    8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
    9. GET参数通过URL传递，POST放在Request body中。
    10. GET产生一个TCP数据包，POST产生两个TCP数据包。GET请求将http header和data一起发送，POST请求先发header，再发送data，返回数据
    
- Cookie存在哪
    * 如果设置了过期时间，Cookie存在硬盘里
    * 没有设置过期时间，Cookie存在内存里

- Session 和 Cookie 的区别，禁用 Cookie 后怎么办
    1. COOKIE保存在客户端，而SESSION则保存在服务器端
    2. 从安全性来讲，SESSION的安全性更高
    3. 从保存内容的类型的角度来讲，COOKIE只保存字符串（及能够自动转换成字符串）
    4. 从保存内容的大小来看，COOKIE保存的内容是有限的，比较小，而SESSION基本上没有这个限制
    5. 从性能的角度来讲，用SESSION的话，对服务器的压力会更大一些
    6. SEEION依赖于COOKIE，但如果禁用COOKIE，也可以通过url传递
## **PHP**

- 描述一下 cli 模式下的几个生命周期？
    1. 模块初始化阶段 (Module init)：即调用每个拓展源码中的的 PHP_MINIT_FUNCTION 中的方法初始化模块，进行一些模块所需变量的申请，内存分配等。
    2. 请求初始化阶段 (Request init)：即接受到客户端的请求后调用每个拓展的 PHP_RINIT_FUNCTION 中的方法，初始化 PHP 脚本的执行环境。
    3. 执行该 PHP 脚本。
    4. 请求结束 (Request Shutdown)：这时候调用每个拓展的 PHP_RSHUTDOWN_FUNCTION 方法清理请求现场，并且 ZE 开始回收变量和内存
    5. 关闭模块 (Module shutdown)：Web 服务器退出或者命令行脚本执行完毕退出会调用拓展源码中的 PHP_MSHUTDOWN_FUNCTION 方法

- laravel 的生命周期
    1. 加载项目依赖，注册加载 composer 自动生成的 class loader，也就是加载初始化第三方依赖。
    2. 创建应用实例，生成容器 Container，并向容器注册核心组件，是从 bootstrap/app.php 脚本获取 Laravel 应用实例，并且绑定内核服务容器，它是 HTTP 请求的运行环境的不同，将请求发送至相应的内核： HTTP 内核 或 Console 内核。
    3. 接收请求并响应，请求被发送到 HTTP 内核或 Console 内核，这取决于进入应用的请求类型。HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，该类定义了一个 bootstrappers 数组，这个数组中的类在请求被执行前运行，这些 bootstrappers 配置了错误处理、日志、检测应用环境以及其它在请求被处理前需要执行的任务。HTTP 内核还定义了一系列所有请求在处理前需要经过的 HTTP 中间件，这些中间件处理 HTTP 会话的读写、判断应用是否处于维护模式、验证 CSRF 令牌等等。
    4. 发送请求，在 Laravel 基础的服务启动之后，把请求传递给路由了。路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。传递给路由是通过 Pipeline（管道）来传递的，在传递给路由之前所有请求都要经过 app\Http\Kernel.php 中的 $middleware 数组，也就是中间件，默认只有一个全局中间件，用来检测你的网站是否暂时关闭。所有请求都要经过，你也可以添加自己的全局中间件。然后遍历所有注册的路由，找到最先符合的第一个路由，经过它的路由中间件，进入到控制器或者闭包函数，执行你的具体逻辑代码，把那些不符合或者恶意的的请求已被 Laravel 隔离在外。

- PHP7 为什么比 PHP5 性能提升了
    1、变量存储字节减小，减少内存占用，提升变量操作速度
    2、改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率
    3、改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率
    
- PHP7 与 PHP5 
    1. 性能提升：PHP7 比 PHP5.0 性能提升了两倍。
    2. 全面一致的 64 位支持。
    3. 以前的许多致命错误，现在改成 [抛出异常]。
    4. PHP 7.0 比 PHP5.0 移除了一些老的不在支持的 SAPI（[服务器端] 应用编程端口）和扩展。
    5. .PHP 7.0 比 PHP5.0 新增了空接合操作符。
    6. PHP 7.0 比 PHP5.0 新增加了结合比较运算符。
    7. PHP 7.0 比 PHP5.0 新增加了函数的返回类型声明。
    8. PHP 7.0 比 PHP5.0 新增加了标量类型声明。
    9. PHP 7.0 比 PHP5.0 新增加匿名类。


- php-fpm 运行机制？（master 管理，worker 循环 accept）

- php-fpm 模式下，kill -9 master-pid，会怎么样？kill matser-pid 呢？（信号机制）

- 内存分配流程？为什么要这么设计？

- GC 的出现是为了解决什么问题？什么时候会触发 GC？说下大概流程

- php 里的数组是怎么实现的？（这里要注意下 php5 和 php7 实现的区别，优化了非常多）

- nginx 和 php-fpm 的通信机制？fast-cgi 和 cgi 区别？

- php-fpm 创建 worker 进程的规则是什么？不同场景下怎么选择？

- php 和 mysql 的通信机制？长链接和短链接啥区别？怎么实现的？连接池要怎么实现？

- swoole 协程的原理？（遇到阻塞时引发 php 栈和 c 栈的切换，细节可以参考下我的文章）

- 依赖注入是什么？如何实现的？能解决什么问题？（代码层面不再依赖具体实现，解耦）

## **mysql**

- innodb 的索引组织方式？（聚簇索引必须要很清楚，注意 innodb 聚簇索引叶子结点保存的是完整数据，innodb 普通索引叶子保存的是记录的主键，myisam 索引叶子保存的是记录的位置 / 偏移量）

- B + 树的结构和插入细节？为什么主键一般都要自增？和 B 树什么区别？为什么索引要使用 B + 树不是 B 树也不是其他的平衡树？为什么 redis 可以用跳表？（关键词：页的分裂，随机 IO，缓存体系）

- 常见的优化（这里我就不展开了，主要考察覆盖索引查询和最左匹配，其实只要清楚 innodb 索引的结构，这些都不需要记忆，自然而然推导出来的）

- redolog/undolog/binlog 的区别？binlog 的几种格式？说下两阶段提交？

- 事务隔离级别和不同级别会出现的问题，innodb 默认哪个级别？MVCC 怎么实现的？快照读和当前读有啥区别？幻读的问题怎么解决？

- 死锁什么时候会出现？应用层应该怎么做避免死锁？mysql 是怎么处理死锁的呢？

- int 占多少字节？bigint 呢？int (3) 和 int (11) 有区别吗？可以往 int (3) 里存 1 亿吗？varchar 最长多少？

- sql 的执行流程（原始 sql-> 词法语法分析生成 AST-> 关系代数表达式（逻辑计划）-> 逻辑优化（谓词下推 / 常量传递）-> 物理查询优化（计算最佳 cost 路径，扫表还是使用索引，join 算法）-> 执行，仅做参考）

## **redis**

- sds 的结构是什么？为什么要存长度？跟 c 里的字符串有什么区别？（关键词：获取长度复杂度 O (1) 和 O (n)，二进制安全，保存 \0，跟 C 库字符串函数可以通用）

- hash 怎么实现的？怎么解决 hash 冲突？除了 hashTable 还有别的吗？

- zset 怎么实现的？跳表是怎么插入的？为什么选择跳表不用其他平衡二叉树？除了跳表还有别的吗？

- rehash 过程？会主动 rehash 吗？

- 用 redis 可以实现队列吗？有什么优点和缺点？

- 用 redis 怎么实现一个延时队列？

- rdb 和 aof 过程？rdb 为什么可以用创建子进程的方式进行？（这里考察一个 cow）这两种持久化方式会丢数据吗？

- redis 为什么快？（主要考察一个 IO 多路复用和单线程不加锁）

- 一致性哈希是什么？节点较少时数据分布不均匀怎么办？

- 简单说下几种 key 的淘汰策略，redis 里的 lru 算法，什么时候会触发？实现细节是什么？怎么保证淘汰合理的 key？

- lua 脚本的作用是什么？

- 缓存击穿 / 穿透 / 雪崩的处理策略

## **nginx**

- LVS 和 Nginx 分别作用在 osi 哪一层？

- 负载均衡算法
    1. 轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。
    2. Weight 指定轮询几率，weight 和访问比率成正比， 用于后端服务器性能不均的情况。
    3. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。
    4. fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。
    5. url_hash（第三方）

## **数据结构**

- 布隆过滤器，什么时候用？优点是什么？

## **算法**



