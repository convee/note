# PHP 面试要点

## 简单做一下自我介绍?  介绍一下三年内最得意的项目？

## **操作系统**

- IO 多路复用是什么？有哪些 api？

- select 和 epoll 的区别？水平触发和边缘触发的区别是啥？使用的时候需要注意什么？
    - select：fd_setsize有限制1024，fd基于数组存储，每次调用都要将fd集合从用户态拷贝到内核态，每次调用都需要在内核中遍历所有的fd
    - poll：本质和select没有区别，fd_size不限制，原因是fd是基于链表存储的
    - epoll：fd_size不限制，fd基于红黑树存储，同时每一次通过epoll_ctl来将fd加入内核中 
- epoll 储存描述符的数据结构是什么？

- select 有描述符限制吗？是多少？

- 进程 / 线程 / 协程区别？go 和 swoole 的协程实现有啥区别？（分配资源的基本单位 / 运行和调度的基本单位 / 用户线程，M:N 模型和 N:1 模型）

## **计算机网络**
- TCP 三次握手的流程
1. 客户端发送一个 SYN 标志位置 1 的包，指明客户端要连接服务器端的接口，发送完毕后，客户端进入 SYN_SEND 状态
2. 服务器发回确认包 (ACK) 应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。
3. 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

- TCP 三次握手和四次挥手，为什么三次握手，为什么四次挥手
    在Tcp连接中，服务端的SYN和ACK向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的ACK和FIN是分两次发送的。因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了
    
- 一次完整的 HTTP 请求（从浏览器输入 www.baidu.com 到加载出页面发生了什么）
    1. dns 解析 ip port
    2. 建立 tcp 连接 
    3. 发送 HTTP 报文 
    4. 接收 HTTP 报文 
    5. 浏览器解析显示
    6. 断开 tcp 连接

- HTTP 协议包括哪些请求？
    1. GET：请求读取由URL所标志的信息。
    2. POST：给服务器添加信息（如注释）。
    3. PUT：在给定的URL下存储一个文档。
    4. DELETE：删除给定的URL所标志的资源。

- GET 和 POST 区别
    1. GET在浏览器回退时是无害的，而POST会再次提交请求。
    2. GET产生的URL地址可以被Bookmark，而POST不可以。
    3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
    4. GET请求只能进行url编码，而POST支持多种编码方式application/x-www-form-urlencoded，multipart/form-data，application/json，text/xml
    5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
    6. GET请求在URL中传送的参数是有长度限制的，而POST没有。
    7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
    8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
    9. GET参数通过URL传递，POST放在Request body中。
    10. GET产生一个TCP数据包，POST产生两个TCP数据包。GET请求将http header和data一起发送，POST请求先发header，再发送data，返回数据
    
- Cookie存在哪
    * 如果设置了过期时间，Cookie存在硬盘里
    * 如果没有设置过期时间，Cookie存在内存里（会随着浏览器的关闭而消失）

- Session 和 Cookie 的区别，禁用 Cookie 后怎么办
    1. COOKIE保存在客户端，而SESSION则保存在服务器端
    2. 从安全性来讲，SESSION的安全性更高
    3. 从保存内容的类型的角度来讲，COOKIE只保存字符串（及能够自动转换成字符串）
    4. 从保存内容的大小来看，COOKIE保存的内容是有限的，比较小，而SESSION基本上没有这个限制
    5. 从性能的角度来讲，用SESSION的话，对服务器的压力会更大一些
    6. SEEION依赖于COOKIE，但如果禁用COOKIE，也可以通过url传递
    
## **PHP**
- PHP执行过程
    - 扫描：将index.php内容变成一个个语言片段（token）
    - 解析：将一个个语言片段有意义的表达式
    - 编译：将表达式编译成中间码（opcode）
    - 执行：将中间码一条条的执行
    - 输出：将要输出的内容输出到缓冲区

- PHP 的解析方式有哪几种？cgi、fastcgi、php-fpm 区别
    - cgi
        - CGI 的英文是（COMMON GATEWAY INTERFACE）公共网关接口，它的作用就是帮助服务器与语言通信，这里就是 nginx 和 php 进行通信，因为 nginx 和 php 的语言不通，因此需要一个沟通转换的过程，而 CGI 就是这个沟通的协议。
        - nginx 服务器在接受到浏览器传递过来的数据后，如果请求的是静态的页面或者图片等无需动态处理的则会直接根据请求的 url 找到其位置然后返回给浏览器，这里无需 php 参与，但是如果是一个动态的页面请求，这个时候 nginx 就必须与 php 通信，这个时候就会需要用到 cgi 协议，将请求数据转换成 php 能理解的信息，然后 php 根据这些信息返回的信息也要通过 cgi 协议转换成 nginx 可以理解的信息，最后 nginx 接到这些信息再返回给浏览器
    - fast-cgi
        - 传统的 cgi 协议在每次连接请求时，会开启一个进程进行处理，处理完毕会关闭该进程，因此下次连接，又要再次开启一个进程进行处理，因此有多少个连接就有多少个 cgi 进程，这也就是为什么传统的 cgi 会显得缓慢的原因，因此过多的进程会消耗资源和内存。
        - 而 fast-cgi 每次处理完请求后，不会 kill 掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新 fork 一个进程了，大大提高效率。
    - php-fpm
        - php-fpm 是 php 提供给 web serve 也就是 http 前端服务器的 fastcgi 协议接口程序，它不会像 php-cgi 一样每次连接都会重新开启一个进程，处理完请求又关闭这个进程，而是允许一个进程对多个连接进行处理，而不会立即关闭这个进程，而是会接着处理下一个连接。它可以说是 php-cgi 的一个管理程序，是对 php-cgi 的改进。
        - php-fpm 会开启多个 php-cgi 程序，并且 php-fpm 常驻内存，每次 web serve 服务器发送连接过来的时候，php-fpm 将连接信息分配给下面其中的一个子程序 php-cgi 进行处理，处理完毕这个 php-cgi 并不会关闭，而是继续等待下一个连接，这也是 fast-cgi 加速的原理，但是由于 php-fpm 是多进程的，而一个 php-cgi 基本消耗 7-25M 内存，因此如果连接过多就会导致内存消耗过大，引发一些问题，例如 nginx 里的 502 错误。
        - 同时 php-fpm 还附带一些其他的功能：
            -  例如平滑过渡配置更改，普通的 php-cgi 在每次更改配置后，需要重新启动才能初始化新的配置，而 php-fpm 是不需要，php-fpm 分将新的连接发送给新的子程序 php-cgi，这个时候加载的是新的配置，而原先正在运行的 php-cgi 还是使用的原先的配置，等到这个连接后下一次连接的时候会使用新的配置初始化，这就是平滑过渡。
- nginx中php-fpm的socket是什么类型。
    - unix socket适合nginx和php-fpm都在一台机器上
    - tcp socket适合nginx和php-fpm不在同一台机器上
    
- cgi、fast-cgi、php-fpm各自的含义。
    - cgi：公共网关接口，http服务器发起请求，会启动对应的实现了cgi协议的php解析器，php解析器解析php.ini，初始化执行环境，并处理请求，在以cgi规定的格式返回结果，推出进程。
    - fast-cgi：由cgi发展而来，是一种进程池，先启动一个master进程，解析php.ini和初始化执行环境，然后启动多个worker进程，php请求发到master进程，通过master进程分发的到worker进程进行处理
    - php-fpm：fastcgi进程管理器，用于替换php内核的fastcgi大部分附加功能

    
- 描述一下 cli 模式下的几个生命周期？
    1. 模块初始化阶段 (Module init)：即调用每个拓展源码中的的 PHP_MINIT_FUNCTION 中的方法初始化模块，进行一些模块所需变量的申请，内存分配等。
    2. 请求初始化阶段 (Request init)：即接受到客户端的请求后调用每个拓展的 PHP_RINIT_FUNCTION 中的方法，初始化 PHP 脚本的执行环境。
    3. 执行该 PHP 脚本。
    4. 请求结束 (Request Shutdown)：这时候调用每个拓展的 PHP_RSHUTDOWN_FUNCTION 方法清理请求现场，并且 ZE 开始回收变量和内存
    5. 关闭模块 (Module shutdown)：Web 服务器退出或者命令行脚本执行完毕退出会调用拓展源码中的 PHP_MSHUTDOWN_FUNCTION 方法

- laravel 的生命周期
    1. 加载项目依赖，注册加载 composer 自动生成的 class loader，也就是加载初始化第三方依赖。
    2. 创建应用实例，生成容器 Container，并向容器注册核心组件，是从 bootstrap/app.php 脚本获取 Laravel 应用实例，并且绑定内核服务容器，它是 HTTP 请求的运行环境的不同，将请求发送至相应的内核： HTTP 内核 或 Console 内核。
    3. 接收请求并响应，请求被发送到 HTTP 内核或 Console 内核，这取决于进入应用的请求类型。HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，该类定义了一个 bootstrappers 数组，这个数组中的类在请求被执行前运行，这些 bootstrappers 配置了错误处理、日志、检测应用环境以及其它在请求被处理前需要执行的任务。HTTP 内核还定义了一系列所有请求在处理前需要经过的 HTTP 中间件，这些中间件处理 HTTP 会话的读写、判断应用是否处于维护模式、验证 CSRF 令牌等等。
    4. 发送请求，在 Laravel 基础的服务启动之后，把请求传递给路由了。路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。传递给路由是通过 Pipeline（管道）来传递的，在传递给路由之前所有请求都要经过 app\Http\Kernel.php 中的 $middleware 数组，也就是中间件，默认只有一个全局中间件，用来检测你的网站是否暂时关闭。所有请求都要经过，你也可以添加自己的全局中间件。然后遍历所有注册的路由，找到最先符合的第一个路由，经过它的路由中间件，进入到控制器或者闭包函数，执行你的具体逻辑代码，把那些不符合或者恶意的的请求已被 Laravel 隔离在外。

- PHP7 为什么比 PHP5 性能提升了
    1. 变量存储字节减小，减少内存占用，提升变量操作速度
    2. 改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率
    3. 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率
    
- PHP7 与 PHP5 
    1. 性能提升：PHP7 比 PHP5.0 性能提升了两倍。
    2. 全面一致的 64 位支持。
    3. 以前的许多致命错误，现在改成 [抛出异常]。
    4. PHP 7.0 比 PHP5.0 移除了一些老的不在支持的 SAPI（[服务器端] 应用编程端口）和扩展。
    5. PHP 7.0 比 PHP5.0 新增了空接合操作符。
    6. PHP 7.0 比 PHP5.0 新增加了结合比较运算符。
    7. PHP 7.0 比 PHP5.0 新增加了函数的返回类型声明。
    8. PHP 7.0 比 PHP5.0 新增加了标量类型声明。
    9. PHP 7.0 比 PHP5.0 新增加匿名类。

- GC（垃圾回收） 的出现是为了解决什么问题？什么时候会触发 GC？说下大概流程
    1. PHP 5.3 版本之前都是采用引用计数的方式管理内存
    2. PHP 所有的变量存在一个叫 zval 的变量容器中，当变量被引用的时候，引用计数会+1，变量引用计数变为0时，PHP 将在内存中销毁这个变量
    3. 引用计数中的循环引用，引用计数不会消减为 0，就会导致内存泄露
    4. 在 5.3 版本之后，做了这些优化：
        1. 并不是每次引用计数减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收；
        2. 可以解决循环引用问题；
        3. 可以总将内存泄露保持在一个阈值以下。
    
- 如何解决 PHP 内存溢出问题
    1. 增大 PHP 脚本的内存分配
    2. 变量引用之后及时销毁
    3. 将数据分批处理
    
- php-fpm 运行机制？（master 管理，worker 循环 accept）

- php-fpm 模式下，kill -9 master-pid，会怎么样？kill matser-pid 呢？（信号机制）

- 内存分配流程？为什么要这么设计？

- php 里的数组是怎么实现的？（这里要注意下 php5 和 php7 实现的区别，优化了非常多）

- nginx 和 php-fpm 的通信机制？fast-cgi 和 cgi 区别？

- php-fpm 创建 worker 进程的规则是什么？不同场景下怎么选择？

- php 和 mysql 的通信机制？长链接和短链接啥区别？怎么实现的？连接池要怎么实现？

- swoole 协程的原理？（遇到阻塞时引发 php 栈和 c 栈的切换，细节可以参考下我的文章）

- 依赖注入是什么？如何实现的？能解决什么问题？（代码层面不再依赖具体实现，解耦）

## **mysql**
- Mysql 主从同步了解吗？
    1. MySQL之间的数据复制的基础是二进制日志文件binlog
    2. 台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，
    3. 其它数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，
    4. 如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据的一致性，也就实现了主从复制

- innodb 的索引组织方式？（聚簇索引必须要很清楚，注意 innodb 聚簇索引叶子结点保存的是完整数据，innodb 普通索引叶子保存的是记录的主键，myisam 索引叶子保存的是记录的位置 / 偏移量）

- B + 树的结构和插入细节？为什么主键一般都要自增？和 B 树什么区别？为什么索引要使用 B + 树不是 B 树也不是其他的平衡树？为什么 redis 可以用跳表？（关键词：页的分裂，随机 IO，缓存体系）

- 常见的优化（这里我就不展开了，主要考察覆盖索引查询和最左匹配，其实只要清楚 innodb 索引的结构，这些都不需要记忆，自然而然推导出来的）

- redolog/undolog/binlog 的区别？binlog 的几种格式？说下两阶段提交？

- 事务隔离级别和不同级别会出现的问题，innodb 默认哪个级别？MVCC 怎么实现的？快照读和当前读有啥区别？幻读的问题怎么解决？

- 死锁什么时候会出现？应用层应该怎么做避免死锁？mysql 是怎么处理死锁的呢？

- int 占多少字节？bigint 呢？int (3) 和 int (11) 有区别吗？可以往 int (3) 里存 1 亿吗？varchar 最长多少？

- sql 的执行流程
    （原始 sql-> 词法语法分析生成 AST-> 关系代数表达式（逻辑计划）-> 逻辑优化（谓词下推 / 常量传递）-> 物理查询优化（计算最佳 cost 路径，扫表还是使用索引，join 算法）-> 执行）

## **redis**

- Redis 如何实现持久化
    1. RDB 持久化，将 Redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。
    2. AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 Redis 的协议格式来保存的
    
- sds 的结构是什么？为什么要存长度？跟 c 里的字符串有什么区别？（关键词：获取长度复杂度 O (1) 和 O (n)，二进制安全，保存 \0，跟 C 库字符串函数可以通用）

- hash 怎么实现的？怎么解决 hash 冲突？除了 hashTable 还有别的吗？

- zset 怎么实现的？跳表是怎么插入的？为什么选择跳表不用其他平衡二叉树？除了跳表还有别的吗？

- rehash 过程？会主动 rehash 吗？

- 用 redis 可以实现队列吗？有什么优点和缺点？

- 用 redis 怎么实现一个延时队列？

- rdb 和 aof 过程？rdb 为什么可以用创建子进程的方式进行？（这里考察一个 cow）这两种持久化方式会丢数据吗？

- redis 为什么快？（主要考察一个 IO 多路复用和单线程不加锁）

- 一致性哈希是什么？节点较少时数据分布不均匀怎么办？

- 简单说下几种 key 的淘汰策略，redis 里的 lru 算法，什么时候会触发？实现细节是什么？怎么保证淘汰合理的 key？

- lua 脚本的作用是什么？

- 缓存击穿 / 穿透 / 雪崩的处理策略

## **nginx**

- LVS 和 Nginx 分别作用在 osi 哪一层？

- 负载均衡算法
    1. 轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。
    2. Weight 指定轮询几率，weight 和访问比率成正比， 用于后端服务器性能不均的情况。
    3. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。
    4. fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。
    5. url_hash（第三方）

## **安全防范**
- CSRF 是什么？如何防范？    
    1. CSRF（Cross-site request forgery）通常被叫做「跨站请求伪造」，可以这么理解：攻击者盗用用户身份，从而欺骗服务器，来完成攻击请求。
    2. 防范措施：
        1. 使用验证码
        2. 给每一个请求添加令牌 token 并验证

- XSS 是什么？如何防范？
1. XSS(Cross Site Scripting)，跨站脚本攻击，攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。
2. 防止 XSS 攻击的方式有很多，其核心的本质是：永远不要相信用户的输入数据，始终保持对用户数据的过滤

- 什么是 SQL 注入？SQL注入产生的原因？如何防范？
    1. SQL注入产生的原因：
        1. 程序开发过程中不注意规范书写SQL语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行
    2. 防范措施
        1. 保持对用户数据的过滤（严格检查输入变量的类型和格式）
        2. 过滤和转义特殊字符比如addslashes()函数
        3. 利用mysql的预编译机制（把sql语句的模板（变量采用占位符进行占位）发送给mysql服务器，mysql服务器对sql语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给mysql服务器，直接进行执行，节省了sql查询时间，以及mysql服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到mysql服务器，mysql服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。）



